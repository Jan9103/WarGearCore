/*
 * Copyright 2021 Jan9103 (@jan9103:matrix.org Jan9103.wargear@protonmail.com)
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software,
 * and to permit third-parties to whom the Software is furnished to do so, all
 * subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR
 * ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
package de.jan9103.wargearcore;

import java.io.File;
import java.io.IOException;
import java.util.HashMap;
import java.util.HashSet;
import java.util.UUID;
import java.util.logging.Level;

import org.bukkit.Bukkit;
import org.bukkit.Location;
import org.bukkit.entity.Player;

import de.jan9103.wargearcore.area.WgArea;
import de.jan9103.wargearcore.chat.BcMsg;
import de.jan9103.wargearcore.chat.UChatMsgV3;
import de.jan9103.wargearcore.util.Tab;

/**
 * Basically a HashMap for Users and Timer..
 */
public class UserManager {
	private static int shed=0;
	private static boolean upd=false;
	private static byte x=0,x2=0;
	public static HashSet<User>loadedUsers(){
		return users;
	}

	private static HashSet<User>users      =new HashSet<>();
	private static HashMap<UUID,User>online=new HashMap<>();
	/** Broadcast */
	public static void bc(BcMsg a){
		for(final User b:users) a.a(b);
	}

	/** Broadcast User Written Chat Message */
	public static void bc(UChatMsgV3 a){
		for(final User b:users) a.a(b);
	}

	/** Broadcast Image */
	public static void bcImg(String ol,String ne){
		for(final User b:users) if(b.chatImages){
				if(b.pre16) b.rawMsg(ol); else{
					Player p=b.getPlayer(); if(p!=null) UChatMsgV3.send(p,"[\"\""+ne+"]");
				}
			}
	}

	public static User parseUser(String in){
		for(final User u:users) if(u.getName().equalsIgnoreCase(in)) return u; return null;
	}

	public UserManager(){
		for(final Player p:Bukkit.getServer().getOnlinePlayers()) onJoin(p.getUniqueId());
	}

	/**
	 * used to reset user configs, etc
	 */
	public static void applyDefaultConfig(File userCfg)throws IOException {
		File f=new File(WGC.dataFolder+"/user/_default.usr");

		if(!f.exists()){
			f.createNewFile();
			return;
		}
		C c=new C(f);

		if(!userCfg.exists()) userCfg.createNewFile();
		c.del("authpw");
		c.del("root");
		c.del("name");
		c.del("E");
		c.cy().save(userCfg);
	}

	/** called when someone joins (after the user is created) */
	public static void add(User u){
		if(u==null) return;

		u.join();
		users.add(u);
		online.put(u.uuid,u);
	}

	/** called when someone leaves */
	public static void remove(User u){
		if(u==null) return;

		users.remove(u);
		online.remove(u.uuid);
		u.leave();
	}

	public static User getUser(UUID i){
		final User u=online.get(i);

		if(u!=null) return u;

		return new User(i,false);
	}

	public static User getUser(Player p){
		return getUser(p.getUniqueId());
	}

	public static User getUser(String name){
		Player p=Bukkit.getPlayer(name);

		if(p==null) return null;

		return getUser(p);
	}

	/** called when someone joins (and creates User) */
	public static User onJoin(UUID id){
		final User u=new User(id,WGC.wgcDefence_auth); add(u); return u;
	}

	//public static void onJoin(User u){add(u);}
	public static void onLeave(UUID id){
		final User u=getUser(id);

		if(u==null) return;

		remove(u);
		u.saveCfg();
		for(final User i:users) i.onLeave(u);
	}

	/**
	 * once called by WGC
	 */
	public static void startUpdater(){
		upd =true;
		shed=Bukkit.getScheduler().scheduleSyncRepeatingTask(WGC.wgc,()->{
			for(final User i1:users){
				if(i1.inFight) continue;
				final Location l=i1.eyeLoc();
				boolean upd     =true;
				if(i1.curAr!=null) if(i1.curAr.ii(l)) upd=false;
				if(upd){
					i1.curAr=null;
					for(final WgArea w:WgArea.areas){
						if(!w.ii(l)) continue;
						i1.curAr=w;
						i1.getPlayer().setScoreboard(WGC.noDefSb?Bukkit.getScoreboardManager().getMainScoreboard():w.sb);
						break;
					}
					if(i1.curAr==null) i1.getPlayer().setScoreboard(WGC.sb);
				}
				Tab.auto(i1.getPlayer(),i1);
			}
			if(++x==24){//2min
				x=0;
				for(final User i2:users){
					i2.books.clear();
					i2.cbv2.tick();
					i2.simpReload.tick();
				}
				if(x2++==7){//14min
					x2=0; Bukkit.getLogger().log(Level.INFO,"[WGC] Cleaning and creating backups..");
					Bukkit.getScheduler().runTaskAsynchronously(WGC.wgc,()->{
						final File f=new File(WGC.dataFolder+"/backup");
						Long iii    =System.currentTimeMillis()-3600000L;
						for(final File ii:f.listFiles())
							try{if(Long.parseLong(ii.getName())<iii){
								    for(File i7:ii.listFiles()) i7.delete();
								    ii.delete();
							    }
							}catch(NumberFormatException e){}
						f.mkdir();
						bu();
					});
				}
			}
		},30,100);
	}

	/**
	 * create a backup of things (including WGAreas, etc)
	 */
	private static void bu(){
		final File iiii=new File(WGC.dataFolder+"/backup/"+System.currentTimeMillis());
		int        zzz =1;
		final int  min =WGC.mins();

		for(final WgArea ii:WgArea.areas) // TODO: add delay between area backups
			if(ii.autobu) Bukkit.getScheduler().runTaskLater(WGC.wgc,()->ii.backUp(iiii,true,min),zzz++);
	}

	public static void stopUpdater(){
		if(upd) Bukkit.getScheduler().cancelTask(shed); upd=false;
	}
}
