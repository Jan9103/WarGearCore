/*
 * Copyright 2021 Jan9103 (@jan9103:matrix.org Jan9103.wargear@protonmail.com)
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software,
 * and to permit third-parties to whom the Software is furnished to do so, all
 * subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR
 * ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
package de.jan9103.wargearcore.listener;

import java.util.HashMap;
import java.util.UUID;

import org.bukkit.Bukkit;
import org.bukkit.Material;
import org.bukkit.block.Block;
import org.bukkit.block.BlockFace;
import org.bukkit.block.data.BlockData;
import org.bukkit.block.data.Openable;
import org.bukkit.block.data.type.Switch;
import org.bukkit.craftbukkit.v1_19_R3.CraftWorld;
import org.bukkit.event.player.PlayerInteractEvent;

import de.jan9103.wargearcore.User;
import de.jan9103.wargearcore.UserManager;
import de.jan9103.wargearcore.WGC;
import de.jan9103.wargearcore.chat.Msg;
import net.minecraft.core.BlockPosition;

public class ClickListener {
	public static HashMap<UUID,Block>bs=new HashMap<>();
	public static void a(PlayerInteractEvent e){
		final String is=e.getItem().getItemMeta().getDisplayName();

		e.setCancelled(true);
		final User u=UserManager.getUser(e.getPlayer());

		switch(e.getAction()){
		case LEFT_CLICK_AIR:
			if(!e.getPlayer().isSneaking()){
				e.getPlayer().performCommand("simplereload paste");
				return;
			}
			new Msg(u).b("You have to lclick an block, not air.").a(e.getPlayer()); return;

		case LEFT_CLICK_BLOCK: {
			if(!e.getPlayer().isSneaking()){
				e.getPlayer().performCommand("simplereload paste");
				return;
			}
			final Block b=e.getPlayer().getTargetBlock(null,10);
			if(b==null){
				new Msg(u).b("You have to lclick an valid block.").a(e.getPlayer()); return;
			}
			if(is==null) u.fernzNull=b;
			else u.fernz.put(is,b);
			new Msg(u).a("Selected target.").a(e.getPlayer());
			return;
		}

		case RIGHT_CLICK_AIR:
		case RIGHT_CLICK_BLOCK: {
			boolean     as=false;
			final Block b =is==null?u.fernzNull:u.fernz.get(is);
			if(b==null){
				new Msg(u).b("Select an block first.").a(e.getPlayer()); return;
			}
			switch(b.getType()){
			case LEVER: {
				final Switch l=(Switch)b.getBlockData();
				l.setPowered(!l.isPowered());
				b.setBlockData(l);
				shbu(b,l);
				if(l.isPowered()) new Msg(u).a("Lever on.").a(e.getPlayer());
				else new Msg(u).a("Lever off.").a(e.getPlayer());
				return;
			}

			case NOTE_BLOCK:
				new Msg(u).b("Triggered an Noteblock").a(e.getPlayer());
				hbu(b); return;

			case OAK_DOOR:
			case SPRUCE_DOOR:
			case BIRCH_DOOR:
			case JUNGLE_DOOR:
			case ACACIA_DOOR:
			case DARK_OAK_DOOR:
			case MANGROVE_DOOR:
			case CHERRY_DOOR:
			case BAMBOO_DOOR:
			case CRIMSON_DOOR:
			case WARPED_DOOR:
			case OAK_FENCE_GATE:
			case SPRUCE_FENCE_GATE:
			case BIRCH_FENCE_GATE:
			case JUNGLE_FENCE_GATE:
			case ACACIA_FENCE_GATE:
			case DARK_OAK_FENCE_GATE:
			case MANGROVE_FENCE_GATE:
			case CHERRY_FENCE_GATE:
			case BAMBOO_FENCE_GATE:
			case CRIMSON_FENCE_GATE:
			case WARPED_FENCE_GATE:
			case OAK_TRAPDOOR:
			case SPRUCE_TRAPDOOR:
			case BIRCH_TRAPDOOR:
			case JUNGLE_TRAPDOOR:
			case ACACIA_TRAPDOOR:
			case DARK_OAK_TRAPDOOR:
			case MANGROVE_TRAPDOOR:
			case CHERRY_TRAPDOOR:
			case BAMBOO_TRAPDOOR:
			case CRIMSON_TRAPDOOR:
			case WARPED_TRAPDOOR: {
				final Openable td=(Openable)b.getBlockData();
				td.setOpen(!td.isOpen());
				b.setBlockData(td);
				if(td.isOpen()) new Msg(u).a("Trapdoor opened.").a(e.getPlayer());
				else new Msg(u).a("Trapdoor closed.").a(e.getPlayer());
				return;
			}

			case STONE_BUTTON: as=true;

			case OAK_BUTTON:
			case DARK_OAK_BUTTON:
			case JUNGLE_BUTTON:
			case ACACIA_BUTTON:
			case BIRCH_BUTTON:
			case SPRUCE_BUTTON:
			case MANGROVE_BUTTON:
			case CHERRY_BUTTON:
			case CRIMSON_BUTTON:
			case WARPED_BUTTON: {
				final Switch a=(Switch)b.getBlockData();
				a.setPowered(true);
				b.setBlockData(a);
				shbu(b,a);
				new Msg(u).a("Triggered button.").a(e.getPlayer());
				Bukkit.getScheduler().runTaskLater(WGC.wgc,(Runnable)()->{
							if(b.getBlockData() instanceof Switch){
								a.setPowered(false);
								b.setBlockData(a);
								shbu(b,a);
							}
						},as?20:30);
				return;
			}

			default: new Msg(u).b("Unable to tigger "+b.getType().toString()+".").a(e.getPlayer()); return;
			}
		}

		default: return;
		}
	}

	private static void hbu(Block b){
		// ((CraftWorld)b.getWorld()).getHandle().removeTileEntity(new BlockPosition(b.getX(),b.getY(),b.getZ()));
		final Material  m =b.getType();
		final BlockData bd=b.getBlockData();

		b.setType(Material.STONE,false);
		b.setType(m);
		b.setBlockData(bd);
	}

	private static void shbu(Block b,Switch l){
		switch(l.getFace()){
		case CEILING: hbu(b.getRelative(BlockFace.UP)); break;

		case FLOOR: hbu(b.getRelative(BlockFace.DOWN)); break;

		case WALL:
			switch(l.getFacing()){
			case EAST: hbu(b.getRelative(BlockFace.WEST)); break;

			case NORTH: hbu(b.getRelative(BlockFace.SOUTH)); break;

			case SOUTH: hbu(b.getRelative(BlockFace.NORTH)); break;

			case WEST: hbu(b.getRelative(BlockFace.EAST)); break;

			default: return;
			}
			break;

		default: return;
		}
	}
}
