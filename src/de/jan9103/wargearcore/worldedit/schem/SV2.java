/*
 * Copyright 2021 Jan9103 (@jan9103:matrix.org Jan9103.wargear@protonmail.com)
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software,
 * and to permit third-parties to whom the Software is furnished to do so, all
 * subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR
 * ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
package de.jan9103.wargearcore.worldedit.schem;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

import org.bukkit.Bukkit;
import org.bukkit.Material;

import de.jan9103.wargearcore.LogHandler;
import de.jan9103.wargearcore.coordSys.BigCoord;
import de.jan9103.wargearcore.worldedit.clip.ChestClipBlock;
import de.jan9103.wargearcore.worldedit.clip.ClipBlockND;
import de.jan9103.wargearcore.worldedit.clip.ClipBlockWD;
import de.jan9103.wargearcore.worldedit.clip.Clipboard;
import de.jan9103.wargearcore.worldedit.clip.ClipboardBlock;
import de.jan9103.wargearcore.worldedit.clip.SignClipBlock;
import de.jan9103.wargearcore.worldedit.clip.WaterlogBlock;

/**
 * SV2
 *
 * SIZE int x,int y,int z
 * POS(rel) x y z
 * POS(abs) x y z
 * data
 *
 * DATA:
 * -126 130 MASK
 * -125 131 Cb-Nd (small materialname)
 * -124 132 Cb-Wd (big data)
 * -123 133 Waterlog (big data)
 * -122 134 Sign (big data) (big txt(\n fuer zeilen))
 * -121 135 repeat once
 * -120 136 repeat (byte) times
 * -119 137 repeat (int) times
 * -118 138 endstone
 * -117 139 air
 * -118 140 (SV2i used)
 *
 * -  1 ERROR
 *    0 NULL (Mask)
 */
public class SV2 extends SchemFormat {
	@Override public Clipboard load(File f){
		if(!f.exists()) try{f.createNewFile();}catch(final IOException e){}
		if(!f.exists()) return null;

		FileInputStream fis=null;

		try{
			fis=new FileInputStream(f);
			final int       xs  =readInt(fis);
			final int       ys  =readInt(fis);
			final int       zs  =readInt(fis);
			final Clipboard c   =new Clipboard(xs,ys,zs);
			ClipboardBlock  zz  =null;
			int             reps=0;
			c.cv=readBigC(fis);
			c.originalCopyPoint=readBigC(fis);
			for(int x=0; x<xs; x++)
				for(int y=0; y<ys; y++)
					for(int z=0; z<zs; z++){
						if(reps!=0){
							reps--; c.clip[x][y][z]=zz; continue;
						}
						switch(fis.read()){
						case 130: zz=null; continue;

						case 131:
							c.clip[x][y][z]=zz=new ClipBlockND(Material.valueOf(new String(readSmall(fis))));
							continue;

						case 132:
							c.clip[x][y][z]=zz=new ClipBlockWD(Bukkit.createBlockData(new String(readBig(fis))));
							continue;

						case 133:
							c.clip[x][y][z]=zz=new WaterlogBlock(Bukkit.createBlockData(new String(readBig(fis))));
							continue;

						case 134:
							c.clip[x][y][z]=zz=new SignClipBlock(Bukkit.createBlockData(new String(readBig(fis))),new String(readBig(fis)).split("\n"));
							continue;

						case 135: c.clip[x][y][z]=zz;

						case 136: c.clip[x][y][z]=zz; reps=fis.read(); continue;

						case 137: c.clip[x][y][z]=zz; reps=readInt(fis); continue;

						case 138: c.clip[x][y][z]=zz=new ClipBlockND(Material.END_STONE); continue;

						case 139: c.clip[x][y][z]=zz=new ClipBlockND(Material.AIR); continue;

						case -1: fis.close(); return c;

						default:
						}
					}
			fis.close();
			return c;
		}catch(final IOException e){if(fis!=null) try{fis.close();}catch(final IOException e1){}LogHandler.handleException(e); return null;}
	}

	@Override public boolean save(File f,Clipboard c){
		if(!f.exists()) try{f.createNewFile();}catch(final IOException e){}
		if(!f.exists()) return false;

		ClipboardBlock   zz  =null;
		int              reps=0;
		FileOutputStream fos =null;

		try{
			fos=new FileOutputStream(f);
			writeInt(c.clip.length,fos);
			writeInt(c.clip[0].length,fos);
			writeInt(c.clip[0][0].length,fos);
			writeBigC(c.cv,fos);
			writeBigC(c.originalCopyPoint,fos);
			for(final ClipboardBlock[][] a:c.clip)
				for(final ClipboardBlock[] b:a)
					for(final ClipboardBlock i:b){
						if(i==null){
							if(zz==null){
								reps++; continue;
							}
							if(reps!=0){
								if(reps==1) fos.write((byte)-121);
								else if(reps<128) fos.write(new byte[] {(byte)-120,(byte)(reps-1)});
								else{
									fos.write((byte)-119);
									writeInt(reps-1,fos);
								}
								reps=0;
							}
							zz=null;
							fos.write((byte)-126);
							continue;
						}
						if(zz==null||!zz.compare(i)){
							if(reps!=0){
								if(reps==1) fos.write((byte)-121);
								else if(reps<128) fos.write(new byte[] {(byte)-120,(byte)(reps-1)});
								else{
									fos.write((byte)-119);
									writeInt(reps-1,fos);
								}
								reps=0;
							}
						}
						else{
							reps++; continue;
						}
						zz=i;
						if(i instanceof ClipBlockND)
							switch(i.getM()){
							case END_STONE: fos.write((byte)-118); continue;

							case AIR: fos.write((byte)-117); continue;

							default: fos.write((byte)-125); saveSmall(i.getM().toString().getBytes(),fos); continue;
							}
						if(i instanceof SignClipBlock){
							fos.write((byte)-122);
							saveBig(i.getD().getAsString().getBytes(),fos);
							String s="";
							for(final String e:((SignClipBlock)i).getTxt()) s+=e+"\n";
							saveBig(s.substring(0,s.length()-1).getBytes(),fos);
							continue;
						}
						if(i instanceof WaterlogBlock||i instanceof ChestClipBlock){
							fos.write((byte)-123);
							saveBig(i.getD().getAsString().getBytes(),fos);
							continue;
						}
						if(i instanceof ClipBlockWD){
							fos.write((byte)-124);
							saveBig(i.getD().getAsString().getBytes(),fos);
							continue;
						}
						fos.write((byte)0);
					}
			if(reps!=0){
				if(reps==1) fos.write((byte)-121);
				else if(reps<128) fos.write(new byte[] {(byte)-120,(byte)(reps-1)});
				else{
					fos.write((byte)-119);
					writeInt(reps-1,fos);
				}
			}
			fos.flush();
			fos.close();
			f.setLastModified(System.currentTimeMillis());
			return true;
		}catch(final IOException e){if(fos!=null) try{fos.close();}catch(final IOException e1){}LogHandler.handleException(e); return false;}
	}

	//private void saveBool(boolean b,FileOutputStream fos)throws IOException{fos.write(b?(byte)1:(byte)0);}
	private void saveSmall(byte[] a,FileOutputStream fos)throws IOException {
		fos.write((byte)a.length); fos.write(a);
	}

	private void saveBig(byte[] a,FileOutputStream fos)throws IOException {
		writeInt(a.length,fos); fos.write(a);
	}

	private void writeInt(int a,FileOutputStream fos)throws IOException {
		fos.write(intTob4(a));
	}

	private void writeBigC(BigCoord a,FileOutputStream fos)throws IOException {
		fos.write(intTob4(a.x)); fos.write(intTob4(a.y)); fos.write(intTob4(a.z));
	}

	//private boolean readBool(FileInputStream fis)throws IOException{return fis.read()==1;}
	private int readInt(FileInputStream fis)throws IOException {
		return b4ToInt(fis.read(),fis.read(),fis.read(),fis.read());
	}

	private byte[] readSmall(FileInputStream fis)throws IOException {
		final int    s=fis.read();
		final byte[] b=new byte[s];

		for(int i=0; i<s; i++) b[i]=(byte)fis.read();
		return b;
	}

	private byte[] readBig(FileInputStream fis)throws IOException {
		final int    s=readInt(fis);
		final byte[] b=new byte[s];

		for(int i=0; i<s; i++) b[i]=(byte)fis.read();
		return b;
	}

	private BigCoord readBigC(FileInputStream fis)throws IOException {
		return new BigCoord(readInt(fis),readInt(fis),readInt(fis));
	}

	private int b4ToInt(int a,int b,int c,int d){
		return (a&0xFF)<<24|(b&0xFF)<<16|(c&0xFF)<<8|d&0xFF;
	}

	private byte[] intTob4(int i){
		return new byte[] {(byte)(i>>24),(byte)(i>>16),(byte)(i>>8),(byte)i};
	}
}
