/*
 * Copyright 2021 Jan9103 (@jan9103:matrix.org Jan9103.wargear@protonmail.com)
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software,
 * and to permit third-parties to whom the Software is furnished to do so, all
 * subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR
 * ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
package de.jan9103.wargearcore.area;

import java.util.ArrayList;
import java.util.List;

import org.bukkit.Bukkit;
import org.bukkit.Material;
import org.bukkit.block.BlockFace;
import org.bukkit.command.Command;
import org.bukkit.command.CommandSender;
import org.bukkit.command.TabExecutor;
import org.bukkit.entity.Player;

// import com.google.common.base.Enums;

import de.jan9103.wargearcore.User;
import de.jan9103.wargearcore.WGC;
import de.jan9103.wargearcore.area.tb.TB;
import de.jan9103.wargearcore.area.tb.s.ArtiS;
import de.jan9103.wargearcore.area.tb.s.ArtoxS;
import de.jan9103.wargearcore.area.tb.s.KiesS;
import de.jan9103.wargearcore.area.tb.s.MassivS;
import de.jan9103.wargearcore.area.tb.s.Shield;
import de.jan9103.wargearcore.area.tb.s.TechSim;
import de.jan9103.wargearcore.area.tb.s.WallS;
import de.jan9103.wargearcore.chat.Msg;
import de.jan9103.wargearcore.cmds.UserOnlyCmd;
import de.jan9103.wargearcore.coordSys.BigArea;
import de.jan9103.wargearcore.coordSys.BigCoord;
import de.jan9103.wargearcore.util.Parser;
import de.jan9103.wargearcore.worldedit.clip.Clipboard;
import de.jan9103.wargearcore.worldedit.editors.AsyncMultiEditor;
import de.jan9103.wargearcore.worldedit.editors.async.AsyncInvOaO;
import de.jan9103.wargearcore.worldedit.editors.async.AsyncSetO;

public class TbCmd extends UserOnlyCmd implements TabExecutor {
	//TODO sidestep test tb
	//TODO /tb count (+blickrichtung) -> tiefe & Stehen noch
	//TODO /tb xray (b1) (b2)
	@Override public void exe(String[] a,User u,Player p){
		if(u.curAr==null){
			new Msg(u,WGC._PREFIX_2_Area).b("Not inside an area.").a(p); return;
		}
		final WgArea w=u.curAr;

		if(a.length==0){
			w.tb.p(w,u);
			return;
		}
		switch(a[0].toLowerCase()){
		case "set": {
			if(a.length<2){
				Msg.missArg(u,"Area",p); return;
			}
			final TB b=TB.a(a,u);
			if(b==null) return;

			b.a(w.tb);
			w.tb=b;
			return;
		}

		case "shield":
		case "s": {
			final Shield s=pS(a,u,p);
			if(s==null){
				new Msg(u,WGC._PREFIX_2_Area).b("Invalid shield.").a(p); return;
			}
			s.a(w,u);
			return;
		}

		case "add": {
			final Shield s=pS(a,u,p);
			if(s==null){
				new Msg(u,WGC._PREFIX_2_Area).b("Invalid shield.").a(p); return;
			}
			w.tb.aS(s);
			new Msg(u,WGC._PREFIX_2_Area).a("Added shield to the TestBlock config.").a(p);
			return;
		}

		case "removeall": {
			w.tb.rAS();
			new Msg(u,WGC._PREFIX_2_Area).a("Removed all shields from the TestBlock config.").a(p);
			return;
		}

		case "clean": {
			final AsyncMultiEditor e=new AsyncMultiEditor(u);
			//front
			e.a(new AsyncSetO(w.w,new BigArea(w.redWg.low.x,w.redWg.low.y,w.redWg.low.z-1,w.redWg.high.x,w.redWg.high.y+w.ausfahrm,w.redWg.low.z-w.ausfm_front),Material.AIR,false,e))
			//ruecken
			.a(new AsyncSetO(w.w,new BigArea(w.redWg.low.x,w.redWg.low.y,w.redWg.high.z+1,w.redWg.high.x,w.redWg.high.y+w.ausfahrm,w.redWg.high.z+w.ausfahrm),Material.AIR,false,e))
			// low x
			.a(new AsyncSetO(w.w,new BigArea(w.redWg.low.x-1,w.redWg.low.y,w.redWg.low.z-w.ausfm_front,w.redWg.low.x-w.ausfahrm,w.redWg.high.y+w.ausfahrm,w.redWg.high.z+w.ausfahrm),Material.AIR,false,e))
			// high x
			.a(new AsyncSetO(w.w,new BigArea(w.redWg.high.x+1,w.redWg.low.y,w.redWg.low.z-w.ausfm_front,w.redWg.high.x+w.ausfahrm,w.redWg.high.y+w.ausfahrm,w.redWg.high.z+w.ausfahrm),Material.AIR,false,e))
			// top
			.a(new AsyncSetO(w.w,new BigArea(w.redWg.low.x,w.redWg.high.y+1,w.redWg.low.z,w.redWg.high.x,w.redWg.high.y+w.ausfahrm,w.redWg.high.z),Material.AIR,false,e))
			.exe();
			new Msg(u,WGC._PREFIX_2_Area).a("Removed shields.").a(p);
			return;
		}

		case "score": rate(u,p,w); return;

		case "xray": {
			try{final Material m =a.length>1?parseM(a[1]):Material.STONE;
			    final Material r =a.length>2?parseM(a[2]):Material.AIR;
			    AsyncInvOaO    aa=new AsyncInvOaO(w.w,w.redWg,m,r,false,u);
			    if(u.saveUndo) u.saveUndo(aa.getUndo(),"tb-xray");
			    aa.aFromSync();}catch(ArrayIndexOutOfBoundsException e){}
		}
		}
	}

	private void rate(final User u,final Player p,final WgArea a){
		final Long start=System.currentTimeMillis();

		new Msg(u,WGC._PREFIX_2_Area).a("Rating.. please be patient").a(p);
		final Clipboard cb=new Clipboard(a.redWg,p.getWorld(),new BigCoord(p.getLocation()));

		Bukkit.getScheduler().runTaskAsynchronously(WGC.wgc,()->{
			int destroyed=0,blockcount=cb.xSize()*cb.ySize()*cb.zSize(),water=0,score=0,zSwitch=cb.zSize()-Integer.min(cb.zSize()/4,10),abdeckung=0;
			for(int x=0; x<cb.xSize(); x++)
				for(int y=0; y<cb.ySize(); y++){
					for(int z=0; z<zSwitch; z++)
						switch(cb.unsafeM(x,y,z)){
						case AIR: destroyed++; continue;

						case WATER: water++; continue;

						default:
						}
					for(int z=cb.zSize()-1; z>=zSwitch; z--)
						switch(cb.unsafeM(x,y,z)){
						case AIR: destroyed++; score++; continue;

						case WATER: water++; continue;

						default:
						}
				}
			for(int x=cb.xSize()-3; x>0; x-=5)
				for(int y=cb.ySize()-3; y>0; y-=5)
					for(int z=cb.zSize()-3; z>0; z-=5)
						if(cb.unsafeM(x,y,z)==Material.AIR) abdeckung++;
			score       +=destroyed; score+=abdeckung*5;
			float percent=(destroyed/(float)blockcount)*100;
			new Msg(u,WGC._PREFIX_2_Area).a("Testblock Rating Result:")
			.d().a("Percent destroyed: ","Airblocks divided by maximum (not extended) size\nFloat: 4").b(String.format("%.4f",percent))
			.d().a("Blocks destroyed: ","Total count of air blocks within the testblock area\n(includes design)").b(""+destroyed)
			.d().a("Coverage rating: ","Based on Sectors damaged\n(and likelihood of Water survival)").b(""+abdeckung)
			.d().a("Water within testblock: ").b(water+"")
			.d().a("Overall Score: ","Score System: WGC-TB-Score v1.0").b(score+"")
			.d().a("Calculation Time: ").b((System.currentTimeMillis()-start)+"").a("ms (singlethread async)")
			.a(p);
		});
	}

	/**
	 * parse Shield.  
	 * u and p are used for feedback and nullable
	 */
	public static Shield pS(String[] a,User u,Player p){
		if(a.length<2){
			if(p!=null) p.sendMessage("### SHIELD TYPES ###\n"
						  +"- Kies\n"
						  +"- ArtiSchild (position) (fallschacht on/off)\n"
						  +"- Massiv [viewdirektion = position]\n"
						  +"- Wall\n"
						  +"- ArtoX [viewdirection = position]");
			return null;
		}
		boolean plus=a[1].endsWith("+");

		if(plus) a[1]=a[1].substring(0,a[1].length()-1);
		try{switch(a[1].toLowerCase()){
		    case "k":
		    case "kies": return new KiesS();

		    case "as":
		    case "artischild": return new ArtiS(a);

		    case "wall": return new WallS();

		    case "m":
		    case "massiv":
			    if(a.length>2){
						for (BlockFace dir:BlockFace.values())
							if (dir.name().equalsIgnoreCase(a[2]))
								return new MassivS(dir);
				    // BlockFace dir=Enums.getIfPresent(BlockFace.class,a[2]).orNull();
				    // if(dir!=null) return new MassivS(dir);
			    }
			    if(p==null) return null;

			    return new MassivS(Parser.smallDir(p.getEyeLocation().getDirection()));

		    case "tech": return new TechSim();

		    case "artox":
		    case "ax":
			    if(a.length>2){
						for (BlockFace dir:BlockFace.values())
							if (dir.name().equalsIgnoreCase(a[2]))
								return new ArtoxS(dir, plus);
				    // BlockFace dir=Enums.getIfPresent(BlockFace.class,a[2]).orNull();
				    // if(dir!=null) return new ArtoxS(dir,plus);
			    }
			    if(p==null) return null;

			    return new ArtoxS(Parser.smallDir(p.getEyeLocation().getDirection()),plus);
		    }
		}catch(final NumberFormatException e){if(p!=null) new Msg(u,WGC._PREFIX_2_Area).b("Invalid number argument.").a(p); }
		return null;
	}

	public static Material parseM(String in){
		for(final Material m:Material.values())
			if(m.toString().equalsIgnoreCase(in)) return m;

		return null;
	}

	@Override public List<String>onTabComplete(CommandSender arg0,Command arg1,String arg2,String[] a){
		ArrayList<String>o=new ArrayList<>();

		switch(a[0]){
		case "add":
		case "shield":
		case "s": {
			if(a.length>2) return o;

			WgArea w=arg0 instanceof Player?WgArea.inside(((Player)arg0).getLocation()):null;
			o.add("Kies");
			o.add("ArtiSchild");
			o.add("Massiv");
			o.add("tech");
			o.add("wall");
			o.add("ArtoX");
			o.add("ArtoX+");
			if(w!=null)
				o.add("artischild -"+w.ausfm_front);
			return o;
		}

		case "set":
			switch(a.length){
			case 2:
				o.add("2");
				o.add("aimtrainer");
				o.add("schem");
				break;

			case 3:
				switch(a[1]){
				case "3":
				case "aimtrainer":
					o.add("<target size>");
					break;

				case "schem":
					o.add("<name>");
					break;
				}
				break;

			case 4:
				switch(a[1]){
				case "3":
				case "aimtrainer":
					o.add("<target amount>");
					break;
				}
				break;

			default:
			}
			return o;
		}
		if(a.length>1) return o;

		o.add("");
		o.add("Shield");
		o.add("clean");
		o.add("xray");
		o.add("add");
		o.add("removeall");
		o.add("score");
		o.add("set");
		return o;
	}
}
